<?php

declare(strict_types=1);

namespace FluidUI\Docs\Command;

use Symfony\Component\Console\Attribute\AsCommand;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Finder\Finder;
use ReflectionClass;

#[AsCommand(
    name: 'docs:generate-viewhelper-docs',
    description: 'Generate documentation for Fluid ViewHelpers',
)]
class GenerateViewHelperDocsCommand extends Command
{
    protected function configure(): void
    {
        $this
            ->setDescription('Generate Fluid ViewHelper API documentation in Markdown')
            ->addArgument('source', InputArgument::OPTIONAL, 'Source folder containing ViewHelper classes', 'packages/fluid-ui/Classes/ViewHelpers')
            ->addArgument('target', InputArgument::OPTIONAL, 'Target folder to write the markdown files into', 'packages/docs/Resources/Private/Content/docs/viewhelpers');
    }

    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $sourceDir = $input->getArgument('source');
        $targetDir = $input->getArgument('target');

        if (!is_dir($targetDir)) {
            mkdir($targetDir, 0777, true);
        }

        $finder = new Finder();
        $finder->files()->in($sourceDir)->name('*ViewHelper.php');

        foreach ($finder as $file) {
            $className = $this->getClassNameFromFile($file->getRealPath());
            if (!$className) {
                continue;
            }

            $reflection = new ReflectionClass($className);
            $docComment = $reflection->getDocComment() ?: '';

            $shortName = $reflection->getShortName();
            $baseName = preg_replace('/ViewHelper$/', '', $shortName);
            $fileName = lcfirst($baseName) . '.md';
            $targetFile = $targetDir . '/' . $fileName;

            $arguments = $this->extractArguments($reflection);

            $markdown = $this->generateMarkdown($reflection, $docComment, $arguments);

            file_put_contents($targetFile, $markdown);
            $output->writeln("Generated: $targetFile");
        }

        return Command::SUCCESS;
    }

    private function getClassNameFromFile(string $filePath): ?string
    {
        $contents = file_get_contents($filePath);
        $contentsWithoutComments = preg_replace('#//.*|/\*[\s\S]*?\*/#', '', $contents);
        if (
            preg_match('/namespace\s+([^;]+);/', $contentsWithoutComments, $ns) &&
            preg_match('/class\s+([^\s]+)/', $contentsWithoutComments, $cls)
        ) {
            return $ns[1] . '\\' . $cls[1];
        }
        return null;
    }

    private function extractArguments(ReflectionClass $reflection): array
    {
        $args = [];

        if ($reflection->hasMethod('initializeArguments')) {
            $method = $reflection->getMethod('initializeArguments');
            $body = file($method->getFileName());
            $lines = array_slice(
                $body,
                $method->getStartLine() - 1,
                $method->getEndLine() - $method->getStartLine() + 1
            );

            foreach ($lines as $line) {
                // Match 2 to 5 arguments
                if (preg_match(
                    '/->registerArgument\(\s*' .
                        '[\'"]([^\'"]+)[\'"]' . // name (1st)
                        '\s*,\s*[\'"]([^\'"]+)[\'"]' . // type (2nd)
                        '(?:\s*,\s*[\'"]([^\'"]*)[\'"])?' . // description (3rd, optional)
                        '(?:\s*,\s*(true|false))?' . // required (4th, optional)
                        '(?:\s*,\s*(.+?))?' . // default (5th, optional)
                        '\s*\)/i',
                    $line,
                    $m
                )) {
                    $args[] = [
                        'name' => $m[1],
                        'type' => $m[2],
                        'description' => $m[3] ?? '',
                        'required' => isset($m[4]) ? filter_var($m[4], FILTER_VALIDATE_BOOLEAN) : false,
                        'default' => $m[5] ?? 'null',
                    ];
                }
            }
        }

        return $args;
    }

    private function generateMarkdown(ReflectionClass $reflection, string $docComment, array $arguments): string
    {
        $shortName = $reflection->getShortName();
        $baseName = preg_replace('/ViewHelper$/', '', $shortName);
        $name = lcfirst($baseName);

        $content = $this->extractRawDocComment($docComment);

        $markdown = <<<MD
<!-- This file is auto-generated by the docs:generate-viewhelper-docs command. Do not edit directly -->

# ui:$name

{$content}

## Arguments

MD;

        if (empty($arguments)) {
            $markdown .= "\n_None_\n";
        } else {
            // Table header
            $markdown .= "\n| Name | Type | Description | Required | Default |\n";
            $markdown .= "|------|------|-------------|----------|--------|\n";

            foreach ($arguments as $arg) {
                // Escape pipe characters in description
                $description = str_replace('|', '\\|', $arg['description'] ?? '');
                $required = !empty($arg['required']) ? 'Yes' : 'No';
                $default = $arg['default'] ?? '';
                $markdown .= "| `{$arg['name']}` | {$arg['type']} | {$description} | {$required} | {$default} |\n";
            }
        }

        return $markdown;
    }

    private function extractRawDocComment(string $docComment): string
    {
        // Remove /** at the start and */ at the end
        $docComment = preg_replace('#^/\*\*#', '', $docComment);
        $docComment = preg_replace('#\*/$#', '', $docComment);

        $lines = explode("\n", $docComment);
        $cleanLines = [];

        foreach ($lines as $line) {
            // Remove leading * and one optional space after it
            $line = preg_replace('/^\s*\*\s?/', '', $line);
            $cleanLines[] = $line;
        }

        // Preserve all original line breaks exactly
        return implode("\n", $cleanLines);
    }
}
